<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Center-to-Center Lines Across Windows</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    html, body { height: 100%; margin: 0; }
    body { display: grid; place-items: center; background: #0b0f14; color: #e6edf3; font-family: system-ui, sans-serif; }
    #ui { position: fixed; top: 12px; left: 12px; display:flex; gap:8px; }
    button { padding: 8px 12px; border: 0; border-radius: 8px; background: #1f6feb; color: white; cursor: pointer; }
    button:active { transform: translateY(1px); }
    #coords { font: 12px/1.3 monospace; opacity: .8; }
    canvas { position: fixed; inset: 0; width: 100%; height: 100%; display: block; pointer-events: none; }
    .dot {
      position: absolute; width: 10px; height: 10px; border-radius: 50%;
      background: #ffcc00; left: 50%; top: 50%; transform: translate(-50%, -50%);
      box-shadow: 0 0 12px #ffcc00aa;
    }
  </style>
</head>
<body>
  <div id="ui">
    <button id="openWin">open another window</button>
    <div id="coords"></div>
  </div>
  <div class="dot" title="this window center"></div>
  <canvas id="layer"></canvas>

  <script>
    // a simple shared channel for all same-origin windows
    const ch = new BroadcastChannel("centers-demo");

    // track other windows centers by id
    const peers = new Map();
    // give this window a random id
    const myId = Math.random().toString(36).slice(2);

    const canvas = document.getElementById("layer");
    const ctx = canvas.getContext("2d");
    const coordsEl = document.getElementById("coords");
    const openBtn = document.getElementById("openWin");

    function sizeCanvas() {
      const dpr = Math.max(1, window.devicePixelRatio || 1);
      canvas.width = Math.floor(innerWidth * dpr);
      canvas.height = Math.floor(innerHeight * dpr);
      canvas.style.width = "100%";
      canvas.style.height = "100%";
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }

    function getGlobalCenter() {
      // center of this window in "screen" coords relative to primary display
      // note: outerWidth includes window frame which is what screenX/Y are anchored to
      const cx = window.screenX + window.outerWidth / 2;
      const cy = window.screenY + window.outerHeight / 2;
      return { cx, cy };
    }

    function getLocalCenter() {
      // center in local page coords for drawing
      return { x: innerWidth / 2, y: innerHeight / 2 };
    }

    function draw() {
      sizeCanvas();
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      const local = getLocalCenter();
      const me = getGlobalCenter();

      // draw lines from our center to each peer center
      for (const { cx, cy, color } of peers.values()) {
        // convert peer center from global to our local canvas coordinates
        const dx = cx - me.cx;
        const dy = cy - me.cy;
        const endX = local.x + dx;
        const endY = local.y + dy;

        ctx.beginPath();
        ctx.moveTo(local.x, local.y);
        ctx.lineTo(endX, endY);
        ctx.lineWidth = 3;
        ctx.strokeStyle = color || "#58a6ff";
        ctx.stroke();

        // draw a small marker at the canvas edge direction
        ctx.beginPath();
        ctx.arc(endX, endY, 5, 0, Math.PI * 2);
        ctx.fillStyle = color || "#58a6ff";
        ctx.fill();
      }

      // show our own numbers for debugging
      coordsEl.textContent =
        `screenX:${screenX}  screenY:${screenY}  ` +
        `outer:${outerWidth}Ã—${outerHeight}  ` +
        `inner:${innerWidth}Ã—${innerHeight}`;
    }

    // assign a stable color per window for fun
    function colorFromId(id) {
      let h = 0;
      for (let i = 0; i < id.length; i++) h = (h * 31 + id.charCodeAt(i)) % 360;
      return `hsl(${h} 80% 65%)`;
    }

    // broadcast our center periodically and on changes
    function broadcast() {
      const { cx, cy } = getGlobalCenter();
      ch.postMessage({ type: "center", id: myId, cx, cy, color: colorFromId(myId) });
    }

    // handle incoming peer updates
    ch.onmessage = (e) => {
      const msg = e.data || {};
      if (msg.id === myId) return;
      if (msg.type === "center") {
        peers.set(msg.id, { cx: msg.cx, cy: msg.cy, color: msg.color });
        draw();
      } else if (msg.type === "bye") {
        peers.delete(msg.id);
        draw();
      } else if (msg.type === "request") {
        // respond to position requests from new windows
        broadcast();
      }
    };

    // open more windows of the same page
    openBtn.onclick = () => {
      const newWin = window.open(location.href, "_blank", "width=600,height=420,left=80,top=80");
      // ensure we redraw when new window is ready (it will broadcast)
      setTimeout(() => {
        broadcast();
        draw();
      }, 200);
    };

    // update loop
    sizeCanvas();
    draw();
    
    // request positions from existing windows when starting
    ch.postMessage({ type: "request", id: myId });
    // also broadcast our own position after a short delay to ensure window is ready
    setTimeout(() => {
      broadcast();
      draw();
    }, 100);

    // many browsers lack a reliable move event, so poll a bit
    let last = { cx: 0, cy: 0, w: 0, h: 0 };
    setInterval(() => {
      const { cx, cy } = getGlobalCenter();
      if (cx !== last.cx || cy !== last.cy || outerWidth !== last.w || outerHeight !== last.h) {
        last = { cx, cy, w: outerWidth, h: outerHeight };
        broadcast();
        draw();
      }
    }, 120);

    // also react to resize for immediate redraw
    window.addEventListener("resize", () => { 
      sizeCanvas();
      broadcast(); 
      draw(); 
    });
    
    // handle window focus to refresh connections
    window.addEventListener("focus", () => {
      broadcast();
      draw();
    });
    
    window.addEventListener("beforeunload", () => ch.postMessage({ type: "bye", id: myId }));
  </script>
</body>
</html>
